name: Integrate MeTube-DevOps.UserService

on:
  push:
    branches: [ SSCITEST ]
    paths:
      - MeTube-DevOps.UserService/**
  pull_request:
    branches: [ SSCITEST ]
    paths:
      - MeTube-DevOps.UserService/**
  workflow_dispatch:

jobs:
  integrate:
    runs-on: ubuntu-latest
    
    env:
      ASPNETCORE_ENVIRONMENT: Development
      DB_CONNECTION_STRING: "Server=db;Database=MeTubeUserDb;User Id=sa;Password=YourSecretPass123;TrustServerCertificate=True;Encrypt=False;Connect Timeout=30"
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Verify Docker Installation
        run: |
          echo "Docker version:"
          docker --version
          
          echo "Docker info:"
          docker info
          
          echo "Docker Compose version:"
          docker compose version
          
          echo "Verify Docker is running:"
          docker run --rm hello-world
      
      - name: Update docker-compose.yml for CI
        run: |
          cd MeTube-DevOps.UserService
          cat > docker-compose.ci.yml << EOF
          services:
            db:
              image: mcr.microsoft.com/mssql/server:2019-latest
              environment:
                - ACCEPT_EULA=Y
                - SA_PASSWORD=YourSecretPass123
                - MSSQL_PID=Express
                - MSSQL_AGENT_ENABLED=true
              ports:
                - "1433:1433"
              # More forgiving healthcheck
              healthcheck:
                # Let's use a simpler check with a shell command that works in both sqlcmd versions
                test: bash -c "if [ -z \$$(ls -l /var/opt/mssql/log/errorlog* 2>/dev/null) ]; then exit 1; else grep -q 'Server is ready for client connections' /var/opt/mssql/log/errorlog*; fi"
                interval: 10s
                timeout: 5s
                retries: 20
                start_period: 30s
            
            userservice:
              build:
                context: .
                dockerfile: ci.Dockerfile
              ports:
                - "5218:5218"
              environment:
                - ASPNETCORE_ENVIRONMENT=Development
                - ASPNETCORE_URLS=http://+:5218
                - ConnectionStrings__DefaultConnection=Server=db;Database=MeTubeUserDb;User Id=sa;Password=YourSecretPass123;TrustServerCertificate=True;Encrypt=False;Connect Timeout=30
              depends_on:
                db:
                  condition: service_healthy
              healthcheck:
                test: curl --fail http://localhost:5218/swagger/index.html || exit 1
                interval: 10s
                timeout: 5s
                retries: 15
                start_period: 20s
          EOF
          
          # Create a CI-specific Dockerfile
          cat > ci.Dockerfile << EOF
          FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
          WORKDIR /app
          
          # Copy ALL project files needed for restore
          COPY MeTube-DevOps.UserService/*.csproj ./MeTube-DevOps.UserService/
          COPY MeTube-DevOps.UserService.UnitTests/*.csproj ./MeTube-DevOps.UserService.UnitTests/
          COPY MeTube-DevOps.UserService.IntegrTests/*.csproj ./MeTube-DevOps.UserService.IntegrTests/
          COPY MeTube-DevOps.UserService.sln .
          RUN dotnet restore
          
          # Copy the rest of the source
          COPY . .
          
          # Patch Program.cs to fix health check issue
          RUN sed -i '/app.MapHealthChecks/d' ./MeTube-DevOps.UserService/Program.cs
          
          # Build and publish
          RUN dotnet build MeTube-DevOps.UserService/MeTube-DevOps.UserService.csproj -c Release
          RUN dotnet publish MeTube-DevOps.UserService/MeTube-DevOps.UserService.csproj -c Release -o /app/publish
          
          # Runtime image
          FROM mcr.microsoft.com/dotnet/aspnet:9.0
          WORKDIR /app
          COPY --from=build /app/publish .
          
          # Install required tools
          RUN apt-get update && \
              apt-get install -y curl && \
              apt-get clean
          
          EXPOSE 5218
          ENTRYPOINT ["dotnet", "MeTube-DevOps.UserService.dll"]
          EOF

      # Fixed step order - Create unit test Dockerfile with ALL project references
      - name: Create Unit Test Dockerfile
        run: |
          cd MeTube-DevOps.UserService
          cat > ci.unittest.Dockerfile << EOF
          FROM mcr.microsoft.com/dotnet/sdk:9.0
          WORKDIR /app
          
          # Copy ALL project files needed for restore
          COPY MeTube-DevOps.UserService/*.csproj ./MeTube-DevOps.UserService/
          COPY MeTube-DevOps.UserService.UnitTests/*.csproj ./MeTube-DevOps.UserService.UnitTests/
          COPY MeTube-DevOps.UserService.IntegrTests/*.csproj ./MeTube-DevOps.UserService.IntegrTests/
          COPY MeTube-DevOps.UserService.sln .
          
          # Restore packages
          RUN dotnet restore
          
          # Copy the rest of the source
          COPY . .
          
          # Run unit tests
          CMD ["dotnet", "test", "MeTube-DevOps.UserService.UnitTests"]
          EOF

      # Then run unit tests
      - name: Run Unit Tests via Docker
        run: |
          cd MeTube-DevOps.UserService
          docker build -t userservice-test -f ci.unittest.Dockerfile .
          docker run --rm userservice-test

      - name: Build and Start Services
        run: |
          cd MeTube-DevOps.UserService
          docker compose -f docker-compose.ci.yml build
          docker compose -f docker-compose.ci.yml up -d
          
          echo "Waiting for services to be healthy..."
          
          # Wait for SQL Server to start specifically
          echo "Waiting for SQL Server to initialize..."
          for i in {1..30}; do
            if docker compose -f docker-compose.ci.yml exec -T db bash -c "ls -l /var/opt/mssql/log/errorlog* 2>/dev/null | grep -q ." && \
               docker compose -f docker-compose.ci.yml exec -T db bash -c "grep -q 'Server is ready for client connections' /var/opt/mssql/log/errorlog*"; then
              echo "SQL Server is ready!"
              break
            fi
            echo "Attempt $i: SQL Server still initializing..."
            if [ $i -eq 10 ] || [ $i -eq 20 ]; then
              echo "Checking container status:"
              docker compose -f docker-compose.ci.yml ps
              echo "SQL Server logs:"
              docker compose -f docker-compose.ci.yml logs db --tail=20
            fi
            sleep 5
          done
          
          # Now wait for both services to be healthy
          for i in {1..30}; do
            HEALTHY_COUNT=$(docker compose -f docker-compose.ci.yml ps --format json | grep -c '"Health":"healthy"')
            if [ "$HEALTHY_COUNT" -eq "2" ]; then
              echo "All services are healthy!"
              break
            fi
            echo "Attempt $i: Waiting for all services to be healthy..."
            sleep 5
            
            if [ $i -eq 10 ] || [ $i -eq 20 ]; then
              echo "Service status after attempt $i:"
              docker compose -f docker-compose.ci.yml ps
              docker compose -f docker-compose.ci.yml logs --tail=20
            fi
            
            if [ $i -eq 30 ]; then
              echo "Services failed to start. Checking logs..."
              docker compose -f docker-compose.ci.yml logs
              exit 1
            fi
          done
      
      - name: Apply Migrations
        run: |
          cd MeTube-DevOps.UserService
          docker compose -f docker-compose.ci.yml exec -T userservice dotnet ef database update

      - name: Create Integration Test Dockerfile
        run: |
          cd MeTube-DevOps.UserService
          cat > ci.integrationtest.Dockerfile << EOF
          FROM mcr.microsoft.com/dotnet/sdk:9.0
          WORKDIR /app
          
          # Install required dependencies
          RUN apt-get update && \
              apt-get install -y wget gpg curl unzip && \
              curl -sL https://deb.nodesource.com/setup_18.x | bash - && \
              apt-get install -y nodejs && \
              npm i -g playwright@latest && \
              npx playwright install-deps && \
              npx playwright install chromium
          
          # Copy ALL project files for restore
          COPY MeTube-DevOps.UserService/*.csproj ./MeTube-DevOps.UserService/
          COPY MeTube-DevOps.UserService.UnitTests/*.csproj ./MeTube-DevOps.UserService.UnitTests/
          COPY MeTube-DevOps.UserService.IntegrTests/*.csproj ./MeTube-DevOps.UserService.IntegrTests/
          COPY MeTube-DevOps.UserService.sln .
          RUN dotnet restore
          
          # Copy the rest of the source
          COPY . .
          
          # Install Playwright
          RUN dotnet tool install --global Microsoft.Playwright.CLI
          ENV PATH="${PATH}:/root/.dotnet/tools"
          RUN playwright install
          
          # Run integration tests
          CMD ["dotnet", "test", "MeTube-DevOps.UserService.IntegrTests"]
          EOF
          
      - name: Run Integration Tests
        run: |
          cd MeTube-DevOps.UserService
          # Update test host in integration tests to point to the container
          sed -i 's/http:\/\/localhost:5218/http:\/\/userservice:5218/g' MeTube-DevOps.UserService.IntegrTests/UserControllerTests.cs
          
          # Build and run integration tests
          docker build -t userservice-integration-test -f ci.integrationtest.Dockerfile .
          # Use the correct network name (docker compose network name format)
          NETWORK_NAME=$(docker compose -f docker-compose.ci.yml ps --format json | grep -o '"Networks":"[^"]*"' | head -n1 | cut -d'"' -f4)
          echo "Using network: $NETWORK_NAME"
          docker run --network=$NETWORK_NAME userservice-integration-test
        
      - name: Cleanup
        if: always()
        run: |
          cd MeTube-DevOps.UserService
          docker compose -f docker-compose.ci.yml down -v